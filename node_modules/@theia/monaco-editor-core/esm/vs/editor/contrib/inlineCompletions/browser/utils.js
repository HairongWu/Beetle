"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.lengthOfText = exports.addPositions = exports.applyObservableDecorations = exports.ColumnRange = exports.getReadonlyEmptyArray = exports.applyEdits = void 0;
const errors_1 = require("../../../../base/common/errors");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
function applyEdits(text, edits) {
    const transformer = new PositionOffsetTransformer(text);
    const offsetEdits = edits.map(e => {
        const range = range_1.Range.lift(e.range);
        return ({
            startOffset: transformer.getOffset(range.getStartPosition()),
            endOffset: transformer.getOffset(range.getEndPosition()),
            text: e.text
        });
    });
    offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
    for (const edit of offsetEdits) {
        text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);
    }
    return text;
}
exports.applyEdits = applyEdits;
class PositionOffsetTransformer {
    constructor(text) {
        this.lineStartOffsetByLineIdx = [];
        this.lineStartOffsetByLineIdx.push(0);
        for (let i = 0; i < text.length; i++) {
            if (text.charAt(i) === '\n') {
                this.lineStartOffsetByLineIdx.push(i + 1);
            }
        }
    }
    getOffset(position) {
        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
    }
}
const array = [];
function getReadonlyEmptyArray() {
    return array;
}
exports.getReadonlyEmptyArray = getReadonlyEmptyArray;
class ColumnRange {
    constructor(startColumn, endColumnExclusive) {
        this.startColumn = startColumn;
        this.endColumnExclusive = endColumnExclusive;
        if (startColumn > endColumnExclusive) {
            throw new errors_1.BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);
        }
    }
    toRange(lineNumber) {
        return new range_1.Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);
    }
    equals(other) {
        return this.startColumn === other.startColumn
            && this.endColumnExclusive === other.endColumnExclusive;
    }
}
exports.ColumnRange = ColumnRange;
function applyObservableDecorations(editor, decorations) {
    const d = new lifecycle_1.DisposableStore();
    const decorationsCollection = editor.createDecorationsCollection();
    d.add((0, observable_1.autorunOpts)({ debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {
        const d = decorations.read(reader);
        decorationsCollection.set(d);
    }));
    d.add({
        dispose: () => {
            decorationsCollection.clear();
        }
    });
    return d;
}
exports.applyObservableDecorations = applyObservableDecorations;
function addPositions(pos1, pos2) {
    return new position_1.Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);
}
exports.addPositions = addPositions;
function lengthOfText(text) {
    let line = 1;
    let column = 1;
    for (const c of text) {
        if (c === '\n') {
            line++;
            column = 1;
        }
        else {
            column++;
        }
    }
    return new position_1.Position(line, column);
}
exports.lengthOfText = lengthOfText;
//# sourceMappingURL=utils.js.map