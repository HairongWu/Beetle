"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffEditorWidget = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const dom_1 = require("../../../../base/browser/dom");
const arraysFind_1 = require("../../../../base/common/arraysFind");
const errors_1 = require("../../../../base/common/errors");
const event_1 = require("../../../../base/common/event");
const lifecycle_1 = require("../../../../base/common/lifecycle");
const observable_1 = require("../../../../base/common/observable");
require("./style.css");
const editorExtensions_1 = require("../../editorExtensions");
const codeEditorService_1 = require("../../services/codeEditorService");
const codeEditorWidget_1 = require("../codeEditorWidget");
const accessibleDiffViewer_1 = require("./accessibleDiffViewer");
const diffEditorDecorations_1 = require("./diffEditorDecorations");
const diffEditorSash_1 = require("./diffEditorSash");
const hideUnchangedRegionsFeature_1 = require("./hideUnchangedRegionsFeature");
const lineAlignment_1 = require("./lineAlignment");
const movedBlocksLines_1 = require("./movedBlocksLines");
const overviewRulerPart_1 = require("./overviewRulerPart");
const utils_1 = require("./utils");
const position_1 = require("../../../common/core/position");
const range_1 = require("../../../common/core/range");
const editorCommon_1 = require("../../../common/editorCommon");
const editorContextKeys_1 = require("../../../common/editorContextKeys");
const length_1 = require("../../../common/model/bracketPairsTextModelPart/bracketPairsTree/length");
const audioCueService_1 = require("../../../../platform/audioCues/browser/audioCueService");
const contextkey_1 = require("../../../../platform/contextkey/common/contextkey");
const instantiation_1 = require("../../../../platform/instantiation/common/instantiation");
const serviceCollection_1 = require("../../../../platform/instantiation/common/serviceCollection");
const progress_1 = require("../../../../platform/progress/common/progress");
require("./colors");
const delegatingEditorImpl_1 = require("./delegatingEditorImpl");
const diffEditorEditors_1 = require("./diffEditorEditors");
const diffEditorOptions_1 = require("./diffEditorOptions");
const diffEditorViewModel_1 = require("./diffEditorViewModel");
let DiffEditorWidget = class DiffEditorWidget extends delegatingEditorImpl_1.DelegatingEditor {
    get onDidContentSizeChange() { return this._editors.onDidContentSizeChange; }
    get collapseUnchangedRegions() { return this._options.hideUnchangedRegions.get(); }
    constructor(_domElement, options, codeEditorWidgetOptions, _parentContextKeyService, _parentInstantiationService, codeEditorService, _audioCueService, _editorProgressService) {
        var _a;
        super();
        this._domElement = _domElement;
        this._parentContextKeyService = _parentContextKeyService;
        this._parentInstantiationService = _parentInstantiationService;
        this._audioCueService = _audioCueService;
        this._editorProgressService = _editorProgressService;
        this.elements = (0, dom_1.h)('div.monaco-diff-editor.side-by-side', { style: { position: 'relative', height: '100%' } }, [
            (0, dom_1.h)('div.noModificationsOverlay@overlay', { style: { position: 'absolute', height: '100%', visibility: 'hidden', } }, [(0, dom_1.$)('span', {}, 'No Changes')]),
            (0, dom_1.h)('div.editor.original@original', { style: { position: 'absolute', height: '100%' } }),
            (0, dom_1.h)('div.editor.modified@modified', { style: { position: 'absolute', height: '100%' } }),
            (0, dom_1.h)('div.accessibleDiffViewer@accessibleDiffViewer', { style: { position: 'absolute', height: '100%' } }),
        ]);
        this._diffModel = this._register((0, observable_1.disposableObservableValue)('diffModel', undefined));
        this.onDidChangeModel = event_1.Event.fromObservableLight(this._diffModel);
        this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement));
        this._instantiationService = this._parentInstantiationService.createChild(new serviceCollection_1.ServiceCollection([contextkey_1.IContextKeyService, this._contextKeyService]));
        this._boundarySashes = (0, observable_1.observableValue)(this, undefined);
        this._accessibleDiffViewerShouldBeVisible = (0, observable_1.observableValue)(this, false);
        this._accessibleDiffViewerVisible = (0, observable_1.derived)(this, reader => this._options.onlyShowAccessibleDiffViewer.read(reader)
            ? true
            : this._accessibleDiffViewerShouldBeVisible.read(reader));
        this.movedBlocksLinesPart = (0, observable_1.observableValue)(this, undefined);
        this._layoutInfo = (0, observable_1.derived)(this, reader => {
            var _a, _b, _c;
            const width = this._rootSizeObserver.width.read(reader);
            const height = this._rootSizeObserver.height.read(reader);
            const sashLeft = (_a = this._sash.read(reader)) === null || _a === void 0 ? void 0 : _a.sashLeft.read(reader);
            const originalWidth = sashLeft !== null && sashLeft !== void 0 ? sashLeft : Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft);
            const modifiedWidth = width - originalWidth - (this._options.renderOverviewRuler.read(reader) ? overviewRulerPart_1.OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
            const movedBlocksLinesWidth = (_c = (_b = this.movedBlocksLinesPart.read(reader)) === null || _b === void 0 ? void 0 : _b.width.read(reader)) !== null && _c !== void 0 ? _c : 0;
            const originalWidthWithoutMovedBlockLines = originalWidth - movedBlocksLinesWidth;
            this.elements.original.style.width = originalWidthWithoutMovedBlockLines + 'px';
            this.elements.original.style.left = '0px';
            this.elements.modified.style.width = modifiedWidth + 'px';
            this.elements.modified.style.left = originalWidth + 'px';
            this._editors.original.layout({ width: originalWidthWithoutMovedBlockLines, height });
            this._editors.modified.layout({ width: modifiedWidth, height });
            return {
                modifiedEditor: this._editors.modified.getLayoutInfo(),
                originalEditor: this._editors.original.getLayoutInfo(),
            };
        });
        this._diffValue = this._diffModel.map((m, r) => m === null || m === void 0 ? void 0 : m.diff.read(r));
        this.onDidUpdateDiff = event_1.Event.fromObservableLight(this._diffValue);
        codeEditorService.willCreateDiffEditor();
        this._contextKeyService.createKey('isInDiffEditor', true);
        this._domElement.appendChild(this.elements.root);
        this._register((0, lifecycle_1.toDisposable)(() => this._domElement.removeChild(this.elements.root)));
        this._rootSizeObserver = this._register(new utils_1.ObservableElementSizeObserver(this.elements.root, options.dimension));
        this._rootSizeObserver.setAutomaticLayout((_a = options.automaticLayout) !== null && _a !== void 0 ? _a : false);
        this._options = new diffEditorOptions_1.DiffEditorOptions(options, this._rootSizeObserver.width);
        this._contextKeyService.createKey(editorContextKeys_1.EditorContextKeys.isEmbeddedDiffEditor.key, false);
        const isEmbeddedDiffEditorKey = editorContextKeys_1.EditorContextKeys.isEmbeddedDiffEditor.bindTo(this._contextKeyService);
        this._register((0, observable_1.autorun)(reader => {
            /** @description update isEmbeddedDiffEditorKey */
            isEmbeddedDiffEditorKey.set(this._options.isInEmbeddedEditor.read(reader));
        }));
        const comparingMovedCodeKey = editorContextKeys_1.EditorContextKeys.comparingMovedCode.bindTo(this._contextKeyService);
        this._register((0, observable_1.autorun)(reader => {
            var _a;
            /** @description update comparingMovedCodeKey */
            comparingMovedCodeKey.set(!!((_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader)));
        }));
        const diffEditorRenderSideBySideInlineBreakpointReachedContextKeyValue = editorContextKeys_1.EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached.bindTo(this._contextKeyService);
        this._register((0, observable_1.autorun)(reader => {
            /** @description update accessibleDiffViewerVisible context key */
            diffEditorRenderSideBySideInlineBreakpointReachedContextKeyValue.set(this._options.couldShowInlineViewBecauseOfSize.read(reader));
        }));
        this._editors = this._register(this._instantiationService.createInstance(diffEditorEditors_1.DiffEditorEditors, this.elements.original, this.elements.modified, this._options, codeEditorWidgetOptions, (i, c, o, o2) => this._createInnerEditor(i, c, o, o2)));
        this._sash = (0, observable_1.derivedWithStore)(this, (reader, store) => {
            const showSash = this._options.renderSideBySide.read(reader);
            this.elements.root.classList.toggle('side-by-side', showSash);
            if (!showSash) {
                return undefined;
            }
            const result = store.add(new diffEditorSash_1.DiffEditorSash(this._options, this.elements.root, {
                height: this._rootSizeObserver.height,
                width: this._rootSizeObserver.width.map((w, reader) => w - (this._options.renderOverviewRuler.read(reader) ? overviewRulerPart_1.OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH : 0)),
            }));
            store.add((0, observable_1.autorun)(reader => {
                /** @description setBoundarySashes */
                const boundarySashes = this._boundarySashes.read(reader);
                if (boundarySashes) {
                    result.setBoundarySashes(boundarySashes);
                }
            }));
            return result;
        });
        this._register((0, observable_1.recomputeInitiallyAndOnChange)(this._sash));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            /** @description UnchangedRangesFeature */
            this.unchangedRangesFeature = store.add(this._instantiationService.createInstance((0, utils_1.readHotReloadableExport)(hideUnchangedRegionsFeature_1.HideUnchangedRegionsFeature, reader), this._editors, this._diffModel, this._options));
        }));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            /** @description DiffEditorDecorations */
            store.add(new ((0, utils_1.readHotReloadableExport)(diffEditorDecorations_1.DiffEditorDecorations, reader))(this._editors, this._diffModel, this._options));
        }));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            /** @description ViewZoneManager */
            store.add(this._instantiationService.createInstance((0, utils_1.readHotReloadableExport)(lineAlignment_1.ViewZoneManager, reader), this._editors, this._diffModel, this._options, this, () => this.unchangedRangesFeature.isUpdatingViewZones));
        }));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            /** @description OverviewRulerPart */
            store.add(this._instantiationService.createInstance((0, utils_1.readHotReloadableExport)(overviewRulerPart_1.OverviewRulerPart, reader), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map(i => i.modifiedEditor), this._options));
        }));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            /** @description _accessibleDiffViewer */
            this._accessibleDiffViewer = store.add(this._register(this._instantiationService.createInstance((0, utils_1.readHotReloadableExport)(accessibleDiffViewer_1.AccessibleDiffViewer, reader), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (visible, tx) => this._accessibleDiffViewerShouldBeVisible.set(visible, tx), this._options.onlyShowAccessibleDiffViewer.map(v => !v), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((m, r) => { var _a; return (_a = m === null || m === void 0 ? void 0 : m.diff.read(r)) === null || _a === void 0 ? void 0 : _a.mappings.map(m => m.lineRangeMapping); }), this._editors)));
        }));
        const visibility = this._accessibleDiffViewerVisible.map(v => v ? 'hidden' : 'visible');
        this._register((0, utils_1.applyStyle)(this.elements.modified, { visibility }));
        this._register((0, utils_1.applyStyle)(this.elements.original, { visibility }));
        this._createDiffEditorContributions();
        codeEditorService.addDiffEditor(this);
        this._register((0, observable_1.recomputeInitiallyAndOnChange)(this._layoutInfo));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            this.movedBlocksLinesPart.set(store.add(new ((0, utils_1.readHotReloadableExport)(movedBlocksLines_1.MovedBlocksLinesPart, reader))(this.elements.root, this._diffModel, this._layoutInfo.map(i => i.originalEditor), this._layoutInfo.map(i => i.modifiedEditor), this._editors)), undefined);
        }));
        this._register((0, utils_1.applyStyle)(this.elements.overlay, {
            width: this._layoutInfo.map((i, r) => i.originalEditor.width + (this._options.renderSideBySide.read(r) ? 0 : i.modifiedEditor.width)),
            visibility: (0, observable_1.derived)(reader => /** @description visibility */ {
                var _a, _b;
                return (this._options.hideUnchangedRegions.read(reader) && ((_b = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.diff.read(reader)) === null || _b === void 0 ? void 0 : _b.mappings.length) === 0)
                    ? 'visible' : 'hidden';
            }),
        }));
        // Revert change when an arrow is clicked.
        this._register(this._editors.modified.onMouseDown(event => {
            var _a, _b;
            if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes('arrow-revert-change'))) {
                const lineNumber = event.target.position.lineNumber;
                const viewZone = event.target;
                const model = this._diffModel.get();
                if (!model) {
                    return;
                }
                const diffs = (_b = model.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings;
                if (!diffs) {
                    return;
                }
                const diff = diffs.find(d => (viewZone === null || viewZone === void 0 ? void 0 : viewZone.detail.afterLineNumber) === d.lineRangeMapping.modified.startLineNumber - 1 ||
                    d.lineRangeMapping.modified.startLineNumber === lineNumber);
                if (!diff) {
                    return;
                }
                this.revert(diff.lineRangeMapping);
                event.event.stopPropagation();
            }
        }));
        this._register(event_1.Event.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (e) => {
            var _a, _b;
            if ((e === null || e === void 0 ? void 0 : e.reason) === 3 /* CursorChangeReason.Explicit */) {
                const diff = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.find(m => m.lineRangeMapping.modified.contains(e.position.lineNumber));
                if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.modified.isEmpty) {
                    this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineDeleted, { source: 'diffEditor.cursorPositionChanged' });
                }
                else if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.original.isEmpty) {
                    this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineInserted, { source: 'diffEditor.cursorPositionChanged' });
                }
                else if (diff) {
                    this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineModified, { source: 'diffEditor.cursorPositionChanged' });
                }
            }
        }));
        const isDiffUpToDate = this._diffModel.map((m, reader) => m === null || m === void 0 ? void 0 : m.isDiffUpToDate.read(reader));
        this._register((0, observable_1.autorunWithStore)((reader, store) => {
            if (isDiffUpToDate.read(reader) === false) {
                const r = this._editorProgressService.show(true, 1000);
                store.add((0, lifecycle_1.toDisposable)(() => r.done()));
            }
        }));
    }
    getViewWidth() {
        return this._rootSizeObserver.width.get();
    }
    getContentHeight() {
        return this._editors.modified.getContentHeight();
    }
    _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
        const editor = instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, container, options, editorWidgetOptions);
        return editor;
    }
    _createDiffEditorContributions() {
        const contributions = editorExtensions_1.EditorExtensionsRegistry.getDiffEditorContributions();
        for (const desc of contributions) {
            try {
                this._register(this._instantiationService.createInstance(desc.ctor, this));
            }
            catch (err) {
                (0, errors_1.onUnexpectedError)(err);
            }
        }
    }
    get _targetEditor() { return this._editors.modified; }
    getEditorType() { return editorCommon_1.EditorType.IDiffEditor; }
    onVisible() {
        // TODO: Only compute diffs when diff editor is visible
        this._editors.original.onVisible();
        this._editors.modified.onVisible();
    }
    onHide() {
        this._editors.original.onHide();
        this._editors.modified.onHide();
    }
    layout(dimension) { this._rootSizeObserver.observe(dimension); }
    hasTextFocus() { return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus(); }
    saveViewState() {
        var _a;
        const originalViewState = this._editors.original.saveViewState();
        const modifiedViewState = this._editors.modified.saveViewState();
        return {
            original: originalViewState,
            modified: modifiedViewState,
            modelState: (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.serializeState(),
        };
    }
    restoreViewState(s) {
        var _a;
        if (s && s.original && s.modified) {
            const diffEditorState = s;
            this._editors.original.restoreViewState(diffEditorState.original);
            this._editors.modified.restoreViewState(diffEditorState.modified);
            if (diffEditorState.modelState) {
                (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.restoreSerializedState(diffEditorState.modelState);
            }
        }
    }
    createViewModel(model) {
        return this._instantiationService.createInstance(diffEditorViewModel_1.DiffEditorViewModel, model, this._options, this);
    }
    getModel() { var _a, _b; return (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : null; }
    setModel(model) {
        if (!model && this._diffModel.get()) {
            // Transitioning from a model to no-model
            this._accessibleDiffViewer.close();
        }
        const vm = model ? ('model' in model) ? model : this.createViewModel(model) : undefined;
        this._editors.original.setModel(vm ? vm.model.original : null);
        this._editors.modified.setModel(vm ? vm.model.modified : null);
        (0, observable_1.transaction)(tx => {
            this._diffModel.set(vm, tx);
        });
    }
    /**
     * @param changedOptions Only has values for top-level options that have actually changed.
     */
    updateOptions(changedOptions) {
        this._options.updateOptions(changedOptions);
    }
    getContainerDomNode() { return this._domElement; }
    getOriginalEditor() { return this._editors.original; }
    getModifiedEditor() { return this._editors.modified; }
    setBoundarySashes(sashes) {
        this._boundarySashes.set(sashes, undefined);
    }
    get ignoreTrimWhitespace() { return this._options.ignoreTrimWhitespace.get(); }
    get maxComputationTime() { return this._options.maxComputationTimeMs.get(); }
    get renderSideBySide() { return this._options.renderSideBySide.get(); }
    /**
     * @deprecated Use `this.getDiffComputationResult().changes2` instead.
     */
    getLineChanges() {
        var _a;
        const diffState = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get();
        if (!diffState) {
            return null;
        }
        return toLineChanges(diffState);
    }
    getDiffComputationResult() {
        var _a;
        const diffState = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get();
        if (!diffState) {
            return null;
        }
        return {
            changes: this.getLineChanges(),
            changes2: diffState.mappings.map(m => m.lineRangeMapping),
            identical: diffState.identical,
            quitEarly: diffState.quitEarly,
        };
    }
    revert(diff) {
        var _a;
        const model = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model;
        if (!model) {
            return;
        }
        const changes = diff.innerChanges
            ? diff.innerChanges.map(c => ({
                range: c.modifiedRange,
                text: model.original.getValueInRange(c.originalRange)
            }))
            : [
                {
                    range: diff.modified.toExclusiveRange(),
                    text: model.original.getValueInRange(diff.original.toExclusiveRange())
                }
            ];
        this._editors.modified.executeEdits('diffEditor', changes);
    }
    _goTo(diff) {
        this._editors.modified.setPosition(new position_1.Position(diff.lineRangeMapping.modified.startLineNumber, 1));
        this._editors.modified.revealRangeInCenter(diff.lineRangeMapping.modified.toExclusiveRange());
    }
    goToDiff(target) {
        var _a, _b, _c, _d;
        const diffs = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings;
        if (!diffs || diffs.length === 0) {
            return;
        }
        const curLineNumber = this._editors.modified.getPosition().lineNumber;
        let diff;
        if (target === 'next') {
            diff = (_c = diffs.find(d => d.lineRangeMapping.modified.startLineNumber > curLineNumber)) !== null && _c !== void 0 ? _c : diffs[0];
        }
        else {
            diff = (_d = (0, arraysFind_1.findLast)(diffs, d => d.lineRangeMapping.modified.startLineNumber < curLineNumber)) !== null && _d !== void 0 ? _d : diffs[diffs.length - 1];
        }
        this._goTo(diff);
        if (diff.lineRangeMapping.modified.isEmpty) {
            this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineDeleted, { source: 'diffEditor.goToDiff' });
        }
        else if (diff.lineRangeMapping.original.isEmpty) {
            this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineInserted, { source: 'diffEditor.goToDiff' });
        }
        else if (diff) {
            this._audioCueService.playAudioCue(audioCueService_1.AudioCue.diffLineModified, { source: 'diffEditor.goToDiff' });
        }
    }
    revealFirstDiff() {
        const diffModel = this._diffModel.get();
        if (!diffModel) {
            return;
        }
        // wait for the diff computation to finish
        this.waitForDiff().then(() => {
            var _a;
            const diffs = (_a = diffModel.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings;
            if (!diffs || diffs.length === 0) {
                return;
            }
            this._goTo(diffs[0]);
        });
    }
    accessibleDiffViewerNext() { this._accessibleDiffViewer.next(); }
    accessibleDiffViewerPrev() { this._accessibleDiffViewer.prev(); }
    waitForDiff() {
        return __awaiter(this, void 0, void 0, function* () {
            const diffModel = this._diffModel.get();
            if (!diffModel) {
                return;
            }
            yield diffModel.waitForDiff();
        });
    }
    mapToOtherSide() {
        var _a, _b;
        const isModifiedFocus = this._editors.modified.hasWidgetFocus();
        const source = isModifiedFocus ? this._editors.modified : this._editors.original;
        const destination = isModifiedFocus ? this._editors.original : this._editors.modified;
        let destinationSelection;
        const sourceSelection = source.getSelection();
        if (sourceSelection) {
            const mappings = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.map(m => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
            if (mappings) {
                const newRange1 = translatePosition(sourceSelection.getStartPosition(), mappings);
                const newRange2 = translatePosition(sourceSelection.getEndPosition(), mappings);
                destinationSelection = range_1.Range.plusRange(newRange1, newRange2);
            }
        }
        return { destination, destinationSelection };
    }
    switchSide() {
        const { destination, destinationSelection } = this.mapToOtherSide();
        destination.focus();
        if (destinationSelection) {
            destination.setSelection(destinationSelection);
        }
    }
    exitCompareMove() {
        const model = this._diffModel.get();
        if (!model) {
            return;
        }
        model.movedTextToCompare.set(undefined, undefined);
    }
    collapseAllUnchangedRegions() {
        var _a;
        const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
        if (!unchangedRegions) {
            return;
        }
        (0, observable_1.transaction)(tx => {
            for (const region of unchangedRegions) {
                region.collapseAll(tx);
            }
        });
    }
    showAllUnchangedRegions() {
        var _a;
        const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
        if (!unchangedRegions) {
            return;
        }
        (0, observable_1.transaction)(tx => {
            for (const region of unchangedRegions) {
                region.showAll(tx);
            }
        });
    }
};
exports.DiffEditorWidget = DiffEditorWidget;
DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = overviewRulerPart_1.OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH;
exports.DiffEditorWidget = DiffEditorWidget = __decorate([
    __param(3, contextkey_1.IContextKeyService),
    __param(4, instantiation_1.IInstantiationService),
    __param(5, codeEditorService_1.ICodeEditorService),
    __param(6, audioCueService_1.IAudioCueService),
    __param(7, progress_1.IEditorProgressService)
], DiffEditorWidget);
function translatePosition(posInOriginal, mappings) {
    const mapping = (0, arraysFind_1.findLast)(mappings, m => m.original.startLineNumber <= posInOriginal.lineNumber);
    if (!mapping) {
        // No changes before the position
        return range_1.Range.fromPositions(posInOriginal);
    }
    if (mapping.original.endLineNumberExclusive <= posInOriginal.lineNumber) {
        const newLineNumber = posInOriginal.lineNumber - mapping.original.endLineNumberExclusive + mapping.modified.endLineNumberExclusive;
        return range_1.Range.fromPositions(new position_1.Position(newLineNumber, posInOriginal.column));
    }
    if (!mapping.innerChanges) {
        // Only for legacy algorithm
        return range_1.Range.fromPositions(new position_1.Position(mapping.modified.startLineNumber, 1));
    }
    const innerMapping = (0, arraysFind_1.findLast)(mapping.innerChanges, m => m.originalRange.getStartPosition().isBeforeOrEqual(posInOriginal));
    if (!innerMapping) {
        const newLineNumber = posInOriginal.lineNumber - mapping.original.startLineNumber + mapping.modified.startLineNumber;
        return range_1.Range.fromPositions(new position_1.Position(newLineNumber, posInOriginal.column));
    }
    if (innerMapping.originalRange.containsPosition(posInOriginal)) {
        return innerMapping.modifiedRange;
    }
    else {
        const l = lengthBetweenPositions(innerMapping.originalRange.getEndPosition(), posInOriginal);
        return range_1.Range.fromPositions(addLength(innerMapping.modifiedRange.getEndPosition(), l));
    }
}
function lengthBetweenPositions(position1, position2) {
    if (position1.lineNumber === position2.lineNumber) {
        return new length_1.LengthObj(0, position2.column - position1.column);
    }
    else {
        return new length_1.LengthObj(position2.lineNumber - position1.lineNumber, position2.column - 1);
    }
}
function addLength(position, length) {
    if (length.lineCount === 0) {
        return new position_1.Position(position.lineNumber, position.column + length.columnCount);
    }
    else {
        return new position_1.Position(position.lineNumber + length.lineCount, length.columnCount + 1);
    }
}
function toLineChanges(state) {
    return state.mappings.map(x => {
        const m = x.lineRangeMapping;
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let innerChanges = m.innerChanges;
        if (m.original.isEmpty) {
            // Insertion
            originalStartLineNumber = m.original.startLineNumber - 1;
            originalEndLineNumber = 0;
            innerChanges = undefined;
        }
        else {
            originalStartLineNumber = m.original.startLineNumber;
            originalEndLineNumber = m.original.endLineNumberExclusive - 1;
        }
        if (m.modified.isEmpty) {
            // Deletion
            modifiedStartLineNumber = m.modified.startLineNumber - 1;
            modifiedEndLineNumber = 0;
            innerChanges = undefined;
        }
        else {
            modifiedStartLineNumber = m.modified.startLineNumber;
            modifiedEndLineNumber = m.modified.endLineNumberExclusive - 1;
        }
        return {
            originalStartLineNumber,
            originalEndLineNumber,
            modifiedStartLineNumber,
            modifiedEndLineNumber,
            charChanges: innerChanges === null || innerChanges === void 0 ? void 0 : innerChanges.map(m => ({
                originalStartLineNumber: m.originalRange.startLineNumber,
                originalStartColumn: m.originalRange.startColumn,
                originalEndLineNumber: m.originalRange.endLineNumber,
                originalEndColumn: m.originalRange.endColumn,
                modifiedStartLineNumber: m.modifiedRange.startLineNumber,
                modifiedStartColumn: m.modifiedRange.startColumn,
                modifiedEndLineNumber: m.modifiedRange.endLineNumber,
                modifiedEndColumn: m.modifiedRange.endColumn,
            }))
        };
    });
}
//# sourceMappingURL=diffEditorWidget.js.map