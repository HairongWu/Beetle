import { DisposableStore, IDisposable } from '../lifecycle';
import { IReader, IObservable, IObserver, IChangeContext } from './base';
export declare function autorunOpts(options: {
    debugName: string | (() => string | undefined);
}, fn: (reader: IReader) => void): IDisposable;
export declare function autorun(fn: (reader: IReader) => void): IDisposable;
export declare function autorunHandleChanges<TChangeSummary>(options: {
    debugName?: string | (() => string | undefined);
    createEmptyChangeSummary?: () => TChangeSummary;
    handleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;
}, fn: (reader: IReader, changeSummary: TChangeSummary) => void): IDisposable;
export declare function autorunWithStoreHandleChanges<TChangeSummary>(options: {
    debugName?: string | (() => string | undefined);
    createEmptyChangeSummary?: () => TChangeSummary;
    handleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;
}, fn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void): IDisposable;
export declare function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable;
export declare class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {
    private readonly _debugName;
    readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void;
    private readonly createChangeSummary;
    private readonly _handleChange;
    private state;
    private updateCount;
    private disposed;
    private dependencies;
    private dependenciesToBeRemoved;
    private changeSummary;
    get debugName(): string;
    constructor(_debugName: string | (() => string | undefined) | undefined, _runFn: (reader: IReader, changeSummary: TChangeSummary) => void, createChangeSummary: (() => TChangeSummary) | undefined, _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined);
    dispose(): void;
    private _runIfNeeded;
    toString(): string;
    beginUpdate(): void;
    endUpdate(): void;
    handlePossibleChange(observable: IObservable<any>): void;
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    readObservable<T>(observable: IObservable<T>): T;
}
export declare namespace autorun {
    const Observer: typeof AutorunObserver;
}
export declare function autorunDelta<T>(observable: IObservable<T>, handler: (args: {
    lastValue: T | undefined;
    newValue: T;
}) => void): IDisposable;
//# sourceMappingURL=autorun.d.ts.map