import { Event } from '../event';
import { DisposableStore, IDisposable } from '../lifecycle';
import { BaseObservable, IObservable, IReader, ITransaction } from './base';
/**
 * Represents an efficient observable whose value never changes.
 */
export declare function constObservable<T>(value: T): IObservable<T>;
export declare function observableFromPromise<T>(promise: Promise<T>): IObservable<{
    value?: T;
}>;
export declare function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState): Promise<TState>;
export declare function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean): Promise<T>;
export declare function observableFromEvent<T, TArgs = unknown>(event: Event<TArgs>, getValue: (args: TArgs | undefined) => T): IObservable<T>;
export declare class FromEventObservable<TArgs, T> extends BaseObservable<T> {
    private readonly event;
    readonly _getValue: (args: TArgs | undefined) => T;
    private value;
    private hasValue;
    private subscription;
    constructor(event: Event<TArgs>, _getValue: (args: TArgs | undefined) => T);
    private getDebugName;
    get debugName(): string;
    protected onFirstObserverAdded(): void;
    private readonly handleEvent;
    protected onLastObserverRemoved(): void;
    get(): T;
}
export declare namespace observableFromEvent {
    const Observer: typeof FromEventObservable;
}
export declare function observableSignalFromEvent(debugName: string, event: Event<any>): IObservable<void>;
/**
 * Creates a signal that can be triggered to invalidate observers.
 * Signals don't have a value - when they are triggered they indicate a change.
 * However, signals can carry a delta that is passed to observers.
 */
export declare function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;
export declare function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;
export interface IObservableSignal<TChange> extends IObservable<void, TChange> {
    trigger(tx: ITransaction | undefined, change: TChange): void;
}
export declare function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined>;
export declare function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean>;
/**
 * This makes sure the observable is being observed and keeps its cache alive.
 */
export declare function keepObserved<T>(observable: IObservable<T>): IDisposable;
/**
 * This converts the given observable into an autorun.
 */
export declare function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>): IDisposable;
export declare function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>;
export declare function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & {
    clearCache(transaction: ITransaction): void;
};
//# sourceMappingURL=utils.d.ts.map