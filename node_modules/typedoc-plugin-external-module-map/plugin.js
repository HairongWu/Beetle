(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "typedoc"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalModuleMapPlugin = void 0;
    const typedoc_1 = require("typedoc");
    /**
     * This plugin allows you to provide a mapping regexp between your source folder structure, and the module that should be
     * reported in typedoc. It will match the first capture group of your regex and use that as the module name.
     *
     * Based on https://github.com/christopherthielen/typedoc-plugin-external-module-name
     *
     *
     */
    class ExternalModuleMapPlugin {
        initialize(app) {
            app.converter.on(typedoc_1.Converter.EVENT_BEGIN, this.onBegin);
            app.converter.on(typedoc_1.Converter.EVENT_CREATE_DECLARATION, this.onDeclarationBegin);
            app.converter.on(typedoc_1.Converter.EVENT_RESOLVE_BEGIN, this.onBeginResolve);
        }
        /**
         * Triggered when the converter begins converting a project.
         *
         * @param context  The context object describing the current state the converter is in.
         */
        onBegin(context) {
            this.moduleRenames = [];
            //this.options.read();
            this.externalmap = context.converter.application.options.getValue("external-modulemap");
            if (!!this.externalmap) {
                try {
                    console.log("INFO: applying regexp ", this.externalmap, " to calculate module names");
                    this.mapRegExs = Array.isArray(this.externalmap) ? this.externalmap.map(reg => new RegExp(reg)) : [new RegExp(this.externalmap)];
                    this.isMappingEnabled = true;
                    console.log("INFO: Enabled", this.isMappingEnabled);
                }
                catch (e) {
                    console.log("WARN: external map not recognized. Not processing.", e);
                }
            }
        }
        onDeclarationBegin(context, reflection, node) {
            if (!node || !this.isMappingEnabled)
                return;
            var fileName = node.fileName;
            let match;
            for (const reg of this.mapRegExs) {
                match = reg.exec(fileName);
                if (null != match) {
                    break;
                }
            }
            /*
        
            */
            if (null != match) {
                console.log(' Mapping ', fileName, ' ==> ', match[1]);
                this.moduleRenames.push({
                    renameTo: match[1],
                    reflection: reflection
                });
            }
        }
        /**
         * Triggered when the converter begins resolving a project.
         *
         * @param context  The context object describing the current state the converter is in.
         */
        onBeginResolve(context) {
            let projRefs = context.project.reflections;
            let refsArray = Object.keys(projRefs).reduce((m, k) => { m.push(projRefs[k]); return m; }, []);
            // Process each rename
            this.moduleRenames.forEach(item => {
                let renaming = item.reflection;
                // Find an existing module that already has the "rename to" name.  Use it as the merge target.
                let mergeTarget = refsArray.filter(ref => ref.kind === renaming.kind && ref.name === item.renameTo)[0];
                // If there wasn't a merge target, just change the name of the current module and exit.
                if (!mergeTarget) {
                    renaming.name = item.renameTo;
                    return;
                }
                if (!mergeTarget.children) {
                    mergeTarget.children = [];
                }
                // Since there is a merge target, relocate all the renaming module's children to the mergeTarget.
                let childrenOfRenamed = refsArray.filter(ref => ref.parent === renaming);
                childrenOfRenamed.forEach((ref) => {
                    // update links in both directions
                    //console.log(' merging ', mergeTarget, ref);
                    ref.parent = mergeTarget;
                    mergeTarget.children.push(ref);
                });
                // Now that all the children have been relocated to the mergeTarget, delete the empty module
                // Make sure the module being renamed doesn't have children, or they will be deleted
                if (renaming.children)
                    renaming.children.length = 0;
                context.project.removeReflection(renaming);
            });
        }
    }
    exports.ExternalModuleMapPlugin = ExternalModuleMapPlugin;
});
